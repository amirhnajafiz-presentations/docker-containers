<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

		<title>
			Docker and Containers
		</title>

		<link rel="stylesheet" href="css/main.css" />
		<link rel="stylesheet" href="dist/reset.css" />
		<link rel="stylesheet" href="dist/reveal.css" />
		<link rel="stylesheet" href="dist/theme/solarized.css" />
		<link rel="icon" type="image/x-icon" href="favicon.ico" />

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" />
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>
						Docker and Containers
					</h2>
					<div>
						<img src="assets/main-logo.png" width="300" />
					</div>
					<small>
						Cloud Computing Workshop 1
					</small>
					<br />
					<small>
						Presented by Javad Rajabi and Amirhossein Najafizadeh
					</small>
					<br />
					<small>
						Spring 2023
					</small>
				</section>
				<section>
					<h3>
						Workshop Content
					</h3>
					<ul>
						<li>
							Containers
							<ul>
								<li>
									Isolation
								</li>
								<li>
									Architecture
								</li>
								<li>
									Cgroups and Namespaces
								</li>
								<li>
									RunC
								</li>
							</ul>
						</li>
						<li>
							Docker
							<ul>
								<li>
									Image
								</li>
								<li>
									Container
								</li>
								<li>
									Network
								</li>
								<li>
									Volume
								</li>
								<li>
									Dockerfile
								</li>
								<li>
									Dockerhub
								</li>
								<li>
									Docker-Compose
								</li>
								<li>
									Swarm
								</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<p>
						The concept of containers was started way back in 1979 with UNIX chroot. 
						It's an UNIX operating-system system call for changing the root directory of a 
						process and it's children to a new location in the filesystem which is 
						only visible to a given process.<br /><br />
						The 2000s were alight with container technology development and refinement. 
						Google introduced Borg, the organization's container cluster management system, in 2003. 
						It relied on the isolation mechanisms that Linux already had in place.<br /><br />
						Until 2004 that linux added the Cgropus and Namespaces which started a big 
						evolution in containers industery.
					</p>
				</section>
				<section>
					<h3>
						Containers: Isolation
					</h3>
					<p>
						Container isolation involves isolating a containerized application's 
						runtime environment from the host operating system and other 
						processes running on the host.
					</p>
					<img src="assets/isolation.png" width="500" />
				</section>
				<section>
					<h3>
						Containers: Architecture
					</h3>
					<p>
						A <span class="green-highlight">containerized</span> architecture makes it possible to package 
						software and its dependencies in an isolated unit, called a container, 
						which can run consistently in any environment.
					</p>
					<img src="assets/architecture.png" width="500" />
				</section>
				<section>
					<h3>
						Cgroup
					</h3>
					<p>
						Cgroups (abbreviated from <span class="red-highlight">control groups</span>) 
						is a Linux kernel feature that limits,
						accounts for, and isolates the resource usage (CPU, memory, disk I/O, 
						network, etc.) of a collection of processes.
						Engineers at Google started the work on this feature in 2006 
						under the name <span class="blue-highlight">process containers</span>.
					</p>
				</section>
				<section>
					<h3>
						Namespace
					</h3>
					<p>
						Namespaces are a feature of the Linux kernel that partitions kernel 
						resources such that one set of processes <span class="red-highlight">
						sees one set of resources while another</span>
						set of processes sees a different set of resources.<br />
						Namespaces provide isolation of system resources, and cgroups allow for 
						<span class="blue-highlight">fine‑grained control and enforcement of limits for those resources</span>. 
						Containers are not the only way that you can use namespaces and cgroups.
					</p>
				</section>
				<section>
					<h3>
						RunC
					</h3>
					<p>
						RunC is a CLI tool for spawning and running containers on Linux according to the 
						<span class="green-highlight">OCI specification</span>.
						RunC is a universal container runtime created by <span class="blue-highlight">Docker
						</span>. View it on
						<a href="https://github.com/opencontainers/runc">
							Github
						</a>.
					</p>
					<pre><code>
# creating a new containers
runc create mycontainerid

# view the container is created and in the "created" state
runc list

# start the process inside the container
runc start mycontainerid

# now delete the container
runc delete mycontainerid
					</code></pre>
				</section>
				<section>
					<h3>
						Docker
					</h3>
					<p>
						Docker is a software platform that allows you to build, test, and deploy applications quickly. 
						Docker packages software into standardized units called containers that have everything 
						the software needs to run including libraries, system tools, code, and runtime. Docker created
						<span class="blue-highlight">RunC</span> in order to manage containers on a system.
					</p>
				</section>
				<section>
					<h3>
						Docker (cont.)
					</h3>
					<img style="background-color: #fff; padding: 10px;" src="assets/docker.svg" width="650" />
				</section>
				<section>
					<h3>
						Docker: Image
					</h3>
					<p>
						A Docker image is a read-only template that contains a set of 
						instructions for creating a container that can run on the Docker platform.
						An image is a <span class="green-highlight">file that represents a packaged application with all the 
						dependencies needed to run correctly</span>. 
						In other words, we could say that a Docker image is like a Java class. 
						Images are built as a series of layers. Layers are assembled on top of one another.
						<span class="red-highlight">Layers can also be cached</span>.
					</p>
					<img src="assets/image.png" width="400" />
				</section>
				<section>
					<h3>
						Docker: Image (cont.)
					</h3>
					<p>
						Image commands:
					</p>
					<pre><code>
# pull docker image
$ docker pull nginx:latest

# get a list of docker images
$ docker image ls

# build your docker image
$ docker build . -t amirhossein21/nginx:v0.1

# remove an image
$ docker image remove amirhossein21/nginx:v0.1
					</code></pre>
				</section>
				<section>
					<h3>
						Docker: Container
					</h3>
					<p>
						A Docker container image is a lightweight, standalone, executable package of software that 
						includes everything needed to run an application: code, runtime, system tools, system libraries 
						and settings.
					</p>
					<img src="assets/containers.jpeg" width="450" />
				</section>
				<section>
					<h3>
						Docker: Container (cont.)
					</h3>
					<p>
						The key difference between a Docker image and a container is that a Docker 
						image is a read-only immutable template that defines how a container will be realized.<br />
						A Docker container is a runtime instance of a Docker image that gets created 
						when the <span class="blue-highlight">$ docker run command</span> is implemented.
					</p>
				</section>
				<section>
					<h3>
						Docker: Container (cont.)
					</h3>
					<p>
						Container commands:
					</p>
					<pre><code>
# run a container
$ docker run -d -p 80:80 nginx:latest

# view containers
$ docker ps

# remove container
$ docker stop b5ee41eeb951

# get terminal inside a container
$ docker exec -it 39203d3aea67 bash
					</code></pre>
				</section>
				<section>
					<h3>
						Docker: Network
					</h3>
					<p>
						Docker networking allows you to attach a container to as many networks as you like. 
						You can also attach an already running container.<br />
						There are three common Docker network types – 
						bridge networks, used within a single host, overlay networks, 
						for multi-host communication, and macvlan networks which are used to connect Docker 
						containers directly to host network interfaces.
					</p>
					<img src="assets/network.png" width="400" />
				</section>
				<section>
					<h3>
						Network (cont.)
					</h3>
					<p>
						Network commands:
					</p>
					<pre><code>
# create network
$ docker network create node-app-network

# get a list of networks
$ docker network ls

# run a container on network
$ docker run --network=node-app-network -d -p 80:80 nginx:latest

# remove network
$ docker network remove node-app-network
					</code></pre>
				</section>
				<section>
					<h3>
						Docker: Volume
					</h3>
					<p>
						A Docker volume is an independent file system entirely managed by Docker and exists as a 
						normal file or directory on the host, where data is persisted.
						Volumes are the preferred way to persist data in Docker containers and services. 
						Some use cases for volumes include: Sharing data among multiple running containers.
						If you don't explicitly create it, a volume is created the first time it is mounted into a container.
					</p>
					<img src="assets/volume.png" width="400" />
				</section>
				<section>
					<h3>
						Volume (cont.)
					</h3>
					<pre><code>
# create volume
$ docker volume create redisvolume

# get a list of networks
$ docker volume ls

# run a container on network
$ docker run -v redisvolume:/data redis:latest

# remove network
$ docker volume remove redisvolume
					</code></pre>
				</section>
				<section>
					<h3>
						Dockerfile
					</h3>
					<p>
						A Dockerfile is a text document that contains all the commands a user could call on 
						the command line to assemble an image.
					</p>
					<pre><code>
# select a base image
FROM nginx

# run a command
RUN apt-get upgrade

# execute commands
COPY html /var/www/html

# run a cmd command for container
CMD bash
					</code></pre>
				</section>
				<section>
					<h3>
						Dockerhub
					</h3>
					<p>
						Docker Hub is the world’s largest repository of container images with an array of 
						content sources including container community developers, open source projects.
					</p>
					<pre><code>
# login
$ docker login

# push images
$ docker push amirhossein21/nginx:v0.1
					</code></pre>
				</section>
				<section>
					<h3>
						Docker Compose
					</h3>
				</section>
				<section>
					<h3>
						Docker Swarm
					</h3>
				</section>
				<section>
					<h2>
						References
					</h2>
					<ul>
						<li>
							<a href="https://snyk.io/blog/best-practices-for-container-isolation/#:~:text=What%20is%20container%20isolation%2C%20and,processes%20running%20on%20the%20host.">
								https://snyk.io/blog
							</a>
						</li>
						<li>
							<a href="https://www.aquasec.com/cloud-native-academy/container-security/containerized-architecture/#:~:text=What%20is%20a%20Containerized%20Architecture,run%20consistently%20in%20any%20environment.">
								https://aquasec.com/cloud-native-academy
							</a>
						</li>
						<li>
							<a href="https://en.wikipedia.org/wiki/Cgroups#:~:text=cgroups%20(abbreviated%20from%20control%20groups,of%20a%20collection%20of%20processes.">
								https://en.wikipedia.org/wiki/cgroups
							</a>
						</li>
						<li>
							<a href="https://aws.amazon.com/docker/#:~:text=Docker%20is%20a%20software%20platform,tools%2C%20code%2C%20and%20runtime.">
								https://aws.amazon.com/docker
							</a>
						</li>
						<li>
							<a href="https://www.docker.com/products/docker-hub/">
								https://docker.com
							</a>
						</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
